"use strict";(globalThis.webpackChunkrelae_docs=globalThis.webpackChunkrelae_docs||[]).push([[89],{7523:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guides/verifying-signatures","title":"Verifying Webhook Signatures","description":"Learn how to verify that webhooks are actually from Relae and haven\'t been tampered with.","source":"@site/docs/guides/verifying-signatures.md","sourceDirName":"guides","slug":"/guides/verifying-signatures","permalink":"/guides/verifying-signatures","draft":false,"unlisted":false,"editUrl":"https://github.com/WillBallentine/relae-docs/tree/main/docs/guides/verifying-signatures.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Dead Letter Queue (DLQ)","permalink":"/guides/dead-letter-queue"}}');var r=t(4848),i=t(8453);const a={},o="Verifying Webhook Signatures",l={},c=[{value:"Why Verify Signatures?",id:"why-verify-signatures",level:2},{value:"Understanding Relae&#39;s Signature",id:"understanding-relaes-signature",level:2},{value:"Signature Format",id:"signature-format",level:3},{value:"How It&#39;s Generated",id:"how-its-generated",level:3},{value:"Getting Your Webhook Secret",id:"getting-your-webhook-secret",level:2},{value:"Verification Steps",id:"verification-steps",level:2},{value:"Code Examples by Language",id:"code-examples-by-language",level:2},{value:"Node.js / Express",id:"nodejs--express",level:3},{value:"Python / Flask",id:"python--flask",level:3},{value:"Go",id:"go",level:3},{value:"Ruby / Sinatra",id:"ruby--sinatra",level:3},{value:"PHP",id:"php",level:3},{value:"Additional Security Measures",id:"additional-security-measures",level:2},{value:"1. Timestamp Tolerance",id:"1-timestamp-tolerance",level:3},{value:"2. Idempotency",id:"2-idempotency",level:3},{value:"3. IP Allowlisting (Optional)",id:"3-ip-allowlisting-optional",level:3},{value:"Testing Signature Verification",id:"testing-signature-verification",level:2},{value:"Using cURL",id:"using-curl",level:3},{value:"Unit Test Example (Node.js)",id:"unit-test-example-nodejs",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Signature Verification Failing",id:"signature-verification-failing",level:3},{value:"Getting &quot;Timestamp too old&quot; Error",id:"getting-timestamp-too-old-error",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Need Help?",id:"need-help",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"verifying-webhook-signatures",children:"Verifying Webhook Signatures"})}),"\n",(0,r.jsx)(n.p,{children:"Learn how to verify that webhooks are actually from Relae and haven't been tampered with."}),"\n",(0,r.jsx)(n.h2,{id:"why-verify-signatures",children:"Why Verify Signatures?"}),"\n",(0,r.jsx)(n.p,{children:"Webhook signature verification protects against:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spoofed requests"}),": Attackers pretending to be Relae"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Replay attacks"}),": Old webhooks being resent"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Man-in-the-middle attacks"}),": Modified webhook payloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unauthorized access"}),": Requests from unknown sources"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Always Verify Signatures",type:"danger",children:(0,r.jsx)(n.p,{children:"Never process webhooks without verifying signatures in production. This is a critical security measure."})}),"\n",(0,r.jsx)(n.h2,{id:"understanding-relaes-signature",children:"Understanding Relae's Signature"}),"\n",(0,r.jsx)(n.p,{children:"Every webhook forwarded by Relae includes these headers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:"Content-Type: application/json\nUser-Agent: Relae-Webhook-Forwarder/1.0\nX-Relae-Event-ID: evt_abc123...\nX-Relae-Source: stripe\nX-Relae-Timestamp: 1701234567\nX-Relae-Signature: t=1701234567,v1=a1b2c3d4e5f6...\n"})}),"\n",(0,r.jsx)(n.h3,{id:"signature-format",children:"Signature Format"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"X-Relae-Signature"})," header contains:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"t=<timestamp>,v1=<signature>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"t"}),": Unix timestamp when the webhook was forwarded"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"v1"}),": HMAC-SHA256 signature (hex-encoded)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"how-its-generated",children:"How It's Generated"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Relae creates the signed payload: ",(0,r.jsx)(n.code,{children:"{timestamp}.{raw_body}"})]}),"\n",(0,r.jsx)(n.li,{children:"Computes HMAC-SHA256 using your webhook secret"}),"\n",(0,r.jsxs)(n.li,{children:["Formats as: ",(0,r.jsx)(n.code,{children:"t={timestamp},v1={signature}"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"getting-your-webhook-secret",children:"Getting Your Webhook Secret"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Go to ",(0,r.jsx)(n.a,{href:"https://relaehook.com/dashboard",children:"Dashboard"})]}),"\n",(0,r.jsxs)(n.li,{children:["Click ",(0,r.jsx)(n.strong,{children:"Account"})," in the navigation"]}),"\n",(0,r.jsxs)(n.li,{children:["Select the ",(0,r.jsx)(n.strong,{children:"Webhooks"})," tab"]}),"\n",(0,r.jsxs)(n.li,{children:["Copy your ",(0,r.jsx)(n.strong,{children:"Relae Webhook Secret"})," (starts with ",(0,r.jsx)(n.code,{children:"whsec_"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Store it securely in your environment variables:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'export RELAE_WEBHOOK_SECRET="whsec_abc123..."\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Keep It Secret",type:"warning",children:(0,r.jsx)(n.p,{children:"Never commit your webhook secret to version control. Always use environment variables."})}),"\n",(0,r.jsx)(n.h2,{id:"verification-steps",children:"Verification Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extract"})," the signature and timestamp from ",(0,r.jsx)(n.code,{children:"X-Relae-Signature"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parse"})," the values: ",(0,r.jsx)(n.code,{children:"t"})," and ",(0,r.jsx)(n.code,{children:"v1"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reconstruct"})," the signed payload: ",(0,r.jsx)(n.code,{children:"{timestamp}.{raw_body}"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compute"})," HMAC-SHA256 using your secret"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compare"})," computed signature with ",(0,r.jsx)(n.code,{children:"v1"})," (constant-time comparison)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check"})," timestamp tolerance (optional but recommended)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"code-examples-by-language",children:"Code Examples by Language"}),"\n",(0,r.jsx)(n.h3,{id:"nodejs--express",children:"Node.js / Express"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const crypto = require("crypto");\nconst express = require("express");\n\nfunction verifyRelaeWebhook(payload, signature, secret) {\n  // Parse signature: t=timestamp,v1=signature\n  const parts = signature.split(",");\n  const timestamp = parts.find((p) => p.startsWith("t=")).split("=")[1];\n  const receivedSig = parts.find((p) => p.startsWith("v1=")).split("=")[1];\n\n  // Create signed payload\n  const signedPayload = `${timestamp}.${payload}`;\n\n  // Compute HMAC\n  const expectedSig = crypto\n    .createHmac("sha256", secret)\n    .update(signedPayload)\n    .digest("hex");\n\n  // Constant-time comparison\n  return crypto.timingSafeEqual(\n    Buffer.from(receivedSig),\n    Buffer.from(expectedSig),\n  );\n}\n\n// Express middleware\nconst app = express();\n\napp.post("/webhook", express.raw({ type: "application/json" }), (req, res) => {\n  const signature = req.headers["x-relae-signature"];\n  const payload = req.body.toString();\n  const secret = process.env.RELAE_WEBHOOK_SECRET;\n\n  // Verify signature\n  if (!verifyRelaeWebhook(payload, signature, secret)) {\n    return res.status(401).json({ error: "Invalid signature" });\n  }\n\n  // Optional: Check timestamp tolerance\n  const timestamp = parseInt(signature.split(",")[0].split("=")[1]);\n  const now = Math.floor(Date.now() / 1000);\n  const tolerance = 300; // 5 minutes\n\n  if (Math.abs(now - timestamp) > tolerance) {\n    return res.status(401).json({ error: "Timestamp too old" });\n  }\n\n  // Process webhook\n  const event = JSON.parse(payload);\n  console.log("Event ID:", req.headers["x-relae-event-id"]);\n  console.log("Source:", req.headers["x-relae-source"]);\n  console.log("Verified webhook:", event);\n\n  res.json({ received: true });\n});\n\napp.listen(3000);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"python--flask",children:"Python / Flask"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import hmac\nimport hashlib\nimport time\nimport os\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\ndef verify_relae_webhook(payload: str, signature: str, secret: str) -> bool:\n    \"\"\"Verify webhook signature from Relae\"\"\"\n    # Parse signature: t=timestamp,v1=signature\n    parts = signature.split(',')\n    sig_dict = dict(part.split('=') for part in parts)\n\n    timestamp = sig_dict.get('t')\n    received_sig = sig_dict.get('v1')\n\n    if not timestamp or not received_sig:\n        return False\n\n    # Create signed payload\n    signed_payload = f\"{timestamp}.{payload}\"\n\n    # Compute HMAC\n    expected_sig = hmac.new(\n        secret.encode('utf-8'),\n        signed_payload.encode('utf-8'),\n        hashlib.sha256\n    ).hexdigest()\n\n    # Constant-time comparison\n    return hmac.compare_digest(expected_sig, received_sig)\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    signature = request.headers.get('X-Relae-Signature')\n    payload = request.get_data(as_text=True)\n    secret = os.environ['RELAE_WEBHOOK_SECRET']\n\n    # Verify signature\n    if not verify_relae_webhook(payload, signature, secret):\n        return jsonify({'error': 'Invalid signature'}), 401\n\n    # Optional: Check timestamp tolerance\n    timestamp = int(signature.split(',')[0].split('=')[1])\n    now = int(time.time())\n    tolerance = 300  # 5 minutes\n\n    if abs(now - timestamp) > tolerance:\n        return jsonify({'error': 'Timestamp too old'}), 401\n\n    # Access Relae headers\n    event_id = request.headers.get('X-Relae-Event-ID')\n    source = request.headers.get('X-Relae-Source')\n\n    # Process webhook\n    event = request.get_json()\n    print(f\"Event ID: {event_id}\")\n    print(f\"Source: {source}\")\n    print(f\"Verified webhook: {event}\")\n\n    return jsonify({'received': True})\n\nif __name__ == '__main__':\n    app.run(port=3000)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"go",children:"Go"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "crypto/hmac"\n    "crypto/sha256"\n    "crypto/subtle"\n    "encoding/hex"\n    "encoding/json"\n    "fmt"\n    "io"\n    "net/http"\n    "os"\n    "strconv"\n    "strings"\n    "time"\n)\n\nfunc verifyRelaeWebhook(payload, signature, secret string) bool {\n    // Parse signature: t=timestamp,v1=signature\n    parts := strings.Split(signature, ",")\n    var timestamp, sig string\n\n    for _, part := range parts {\n        kv := strings.SplitN(part, "=", 2)\n        if len(kv) != 2 {\n            continue\n        }\n        if kv[0] == "t" {\n            timestamp = kv[1]\n        } else if kv[0] == "v1" {\n            sig = kv[1]\n        }\n    }\n\n    if timestamp == "" || sig == "" {\n        return false\n    }\n\n    // Create signed payload\n    signedPayload := fmt.Sprintf("%s.%s", timestamp, payload)\n\n    // Compute HMAC\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write([]byte(signedPayload))\n    expectedSig := hex.EncodeToString(mac.Sum(nil))\n\n    // Constant-time comparison\n    return subtle.ConstantTimeCompare(\n        []byte(sig),\n        []byte(expectedSig)\n    ) == 1\n}\n\nfunc webhookHandler(w http.ResponseWriter, r *http.Request) {\n    signature := r.Header.Get("X-Relae-Signature")\n\n    payload, err := io.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, "Failed to read body", 400)\n        return\n    }\n\n    secret := os.Getenv("RELAE_WEBHOOK_SECRET")\n\n    // Verify signature\n    if !verifyRelaeWebhook(string(payload), signature, secret) {\n        http.Error(w, "Invalid signature", 401)\n        return\n    }\n\n    // Optional: Check timestamp tolerance\n    parts := strings.Split(signature, ",")\n    timestampStr := strings.TrimPrefix(parts[0], "t=")\n    timestamp, _ := strconv.ParseInt(timestampStr, 10, 64)\n    now := time.Now().Unix()\n    tolerance := int64(300) // 5 minutes\n\n    if abs(now-timestamp) > tolerance {\n        http.Error(w, "Timestamp too old", 401)\n        return\n    }\n\n    // Access Relae headers\n    eventID := r.Header.Get("X-Relae-Event-ID")\n    source := r.Header.Get("X-Relae-Source")\n\n    // Process webhook\n    var event map[string]interface{}\n    json.Unmarshal(payload, &event)\n\n    fmt.Printf("Event ID: %s\\n", eventID)\n    fmt.Printf("Source: %s\\n", source)\n    fmt.Printf("Verified webhook: %v\\n", event)\n\n    w.WriteHeader(200)\n    json.NewEncoder(w).Encode(map[string]bool{"received": true})\n}\n\nfunc abs(n int64) int64 {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc main() {\n    http.HandleFunc("/webhook", webhookHandler)\n    http.ListenAndServe(":3000", nil)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"ruby--sinatra",children:"Ruby / Sinatra"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"require 'sinatra'\nrequire 'openssl'\nrequire 'json'\n\ndef verify_relae_webhook(payload, signature, secret)\n  # Parse signature: t=timestamp,v1=signature\n  sig_parts = signature.split(',').map { |p| p.split('=') }.to_h\n  timestamp = sig_parts['t']\n  received_sig = sig_parts['v1']\n\n  return false if timestamp.nil? || received_sig.nil?\n\n  # Create signed payload\n  signed_payload = \"#{timestamp}.#{payload}\"\n\n  # Compute HMAC\n  expected_sig = OpenSSL::HMAC.hexdigest(\n    OpenSSL::Digest.new('sha256'),\n    secret,\n    signed_payload\n  )\n\n  # Constant-time comparison\n  Rack::Utils.secure_compare(expected_sig, received_sig)\nend\n\npost '/webhook' do\n  request.body.rewind\n  payload = request.body.read\n  signature = request.env['HTTP_X_RELAE_SIGNATURE']\n  secret = ENV['RELAE_WEBHOOK_SECRET']\n\n  # Verify signature\n  unless verify_relae_webhook(payload, signature, secret)\n    halt 401, { error: 'Invalid signature' }.to_json\n  end\n\n  # Optional: Check timestamp tolerance\n  timestamp = signature.split(',')[0].split('=')[1].to_i\n  now = Time.now.to_i\n  tolerance = 300 # 5 minutes\n\n  if (now - timestamp).abs > tolerance\n    halt 401, { error: 'Timestamp too old' }.to_json\n  end\n\n  # Access Relae headers\n  event_id = request.env['HTTP_X_RELAE_EVENT_ID']\n  source = request.env['HTTP_X_RELAE_SOURCE']\n\n  # Process webhook\n  event = JSON.parse(payload)\n  puts \"Event ID: #{event_id}\"\n  puts \"Source: #{source}\"\n  puts \"Verified webhook: #{event}\"\n\n  { received: true }.to_json\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"php",children:"PHP"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"<?php\nfunction verifyRelaeWebhook($payload, $signature, $secret) {\n    // Parse signature: t=timestamp,v1=signature\n    $parts = explode(',', $signature);\n    $timestamp = null;\n    $sig = null;\n\n    foreach ($parts as $part) {\n        list($key, $value) = explode('=', $part, 2);\n        if ($key === 't') {\n            $timestamp = $value;\n        } elseif ($key === 'v1') {\n            $sig = $value;\n        }\n    }\n\n    if (!$timestamp || !$sig) {\n        return false;\n    }\n\n    // Create signed payload\n    $signedPayload = $timestamp . '.' . $payload;\n\n    // Compute HMAC\n    $expectedSig = hash_hmac('sha256', $signedPayload, $secret);\n\n    // Constant-time comparison\n    return hash_equals($expectedSig, $sig);\n}\n\n// Get request data\n$payload = file_get_contents('php://input');\n$signature = $_SERVER['HTTP_X_RELAE_SIGNATURE'] ?? '';\n$secret = getenv('RELAE_WEBHOOK_SECRET');\n\n// Verify signature\nif (!verifyRelaeWebhook($payload, $signature, $secret)) {\n    http_response_code(401);\n    echo json_encode(['error' => 'Invalid signature']);\n    exit;\n}\n\n// Optional: Check timestamp tolerance\n$parts = explode(',', $signature);\n$timestamp = (int)explode('=', $parts[0])[1];\n$now = time();\n$tolerance = 300; // 5 minutes\n\nif (abs($now - $timestamp) > $tolerance) {\n    http_response_code(401);\n    echo json_encode(['error' => 'Timestamp too old']);\n    exit;\n}\n\n// Access Relae headers\n$eventId = $_SERVER['HTTP_X_RELAE_EVENT_ID'] ?? '';\n$source = $_SERVER['HTTP_X_RELAE_SOURCE'] ?? '';\n\n// Process webhook\n$event = json_decode($payload, true);\nerror_log(\"Event ID: $eventId\");\nerror_log(\"Source: $source\");\nerror_log('Verified webhook: ' . print_r($event, true));\n\nhttp_response_code(200);\necho json_encode(['received' => true]);\n?>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"additional-security-measures",children:"Additional Security Measures"}),"\n",(0,r.jsx)(n.h3,{id:"1-timestamp-tolerance",children:"1. Timestamp Tolerance"}),"\n",(0,r.jsx)(n.p,{children:"Always check that the timestamp is recent to prevent replay attacks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const TOLERANCE_SECONDS = 300; // 5 minutes\nconst timestamp = parseInt(signature.split(",")[0].split("=")[1]);\nconst now = Math.floor(Date.now() / 1000);\n\nif (Math.abs(now - timestamp) > TOLERANCE_SECONDS) {\n  return res.status(401).send("Timestamp too old");\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-idempotency",children:"2. Idempotency"}),"\n",(0,r.jsx)(n.p,{children:"Store processed event IDs to prevent duplicate processing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const eventId = req.headers["x-relae-event-id"];\n\n// Check if already processed\nif (await isEventProcessed(eventId)) {\n  return res.status(200).send("Already processed");\n}\n\n// Process event\nawait processWebhook(event);\n\n// Mark as processed\nawait markEventProcessed(eventId);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-ip-allowlisting-optional",children:"3. IP Allowlisting (Optional)"}),"\n",(0,r.jsx)(n.p,{children:"For additional security, you can allowlist Relae's IP addresses. Contact support for the current IP ranges."}),"\n",(0,r.jsx)(n.h2,{id:"testing-signature-verification",children:"Testing Signature Verification"}),"\n",(0,r.jsx)(n.h3,{id:"using-curl",children:"Using cURL"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Get your webhook secret from dashboard\nSECRET="whsec_abc123..."\n\n# Current timestamp\nTIMESTAMP=$(date +%s)\n\n# Payload\nPAYLOAD=\'{"test": true, "event": "payment.succeeded"}\'\n\n# Compute signature\nSIGNATURE=$(echo -n "${TIMESTAMP}.${PAYLOAD}" | \\\n  openssl dgst -sha256 -hmac "${SECRET}" | \\\n  sed \'s/^.* //\')\n\n# Send test webhook\ncurl -X POST http://localhost:3000/webhook \\\n  -H "Content-Type: application/json" \\\n  -H "X-Relae-Signature: t=${TIMESTAMP},v1=${SIGNATURE}" \\\n  -H "X-Relae-Event-ID: evt_test_123" \\\n  -H "X-Relae-Source: test" \\\n  -H "X-Relae-Timestamp: ${TIMESTAMP}" \\\n  -H "User-Agent: Relae-Webhook-Forwarder/1.0" \\\n  -d "${PAYLOAD}"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"unit-test-example-nodejs",children:"Unit Test Example (Node.js)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const assert = require("assert");\nconst crypto = require("crypto");\n\nfunction createTestSignature(payload, secret) {\n  const timestamp = Math.floor(Date.now() / 1000);\n  const signedPayload = `${timestamp}.${payload}`;\n  const signature = crypto\n    .createHmac("sha256", secret)\n    .update(signedPayload)\n    .digest("hex");\n  return `t=${timestamp},v1=${signature}`;\n}\n\n// Test valid signature\nconst secret = "whsec_test_secret";\nconst payload = JSON.stringify({ test: true });\nconst signature = createTestSignature(payload, secret);\n\nassert.strictEqual(\n  verifyRelaeWebhook(payload, signature, secret),\n  true,\n  "Valid signature should pass",\n);\n\n// Test invalid signature\nassert.strictEqual(\n  verifyRelaeWebhook(payload, "t=123,v1=invalid", secret),\n  false,\n  "Invalid signature should fail",\n);\n\nconsole.log("All tests passed!");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"signature-verification-failing",children:"Signature Verification Failing"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Check these common issues:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wrong secret"}),": Make sure you're using the Relae webhook secret (starts with ",(0,r.jsx)(n.code,{children:"whsec_"}),"), not the vendor's secret"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Body modification"}),": Don't parse or modify the body before verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wrong encoding"}),": Use the raw body as a string, not parsed JSON"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incorrect format"}),": Signature is ",(0,r.jsx)(n.code,{children:"t=timestamp,v1=signature"}),", not ",(0,r.jsx)(n.code,{children:"sha256=..."})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timing issues"}),": Timestamp might be outside your tolerance window"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Debug steps:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Log everything for debugging\nconsole.log("Received signature:", signature);\nconsole.log("Raw payload:", payload);\nconsole.log("Secret (first 10 chars):", secret.substring(0, 10));\n\n// Parse signature\nconst parts = signature.split(",");\nconst timestamp = parts[0].split("=")[1];\nconst receivedSig = parts[1].split("=")[1];\n\nconsole.log("Timestamp:", timestamp);\nconsole.log("Received sig:", receivedSig);\n\n// Compute expected\nconst signedPayload = `${timestamp}.${payload}`;\nconst expectedSig = crypto\n  .createHmac("sha256", secret)\n  .update(signedPayload)\n  .digest("hex");\n\nconsole.log("Signed payload:", signedPayload);\nconsole.log("Expected sig:", expectedSig);\nconsole.log("Match:", receivedSig === expectedSig);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"getting-timestamp-too-old-error",children:'Getting "Timestamp too old" Error'}),"\n",(0,r.jsx)(n.p,{children:"This happens when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your server's clock is out of sync"}),"\n",(0,r.jsx)(n.li,{children:"The webhook was delayed in transit"}),"\n",(0,r.jsx)(n.li,{children:"Your tolerance window is too strict"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Solutions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Increase tolerance to 10-15 minutes for development"}),"\n",(0,r.jsx)(n.li,{children:"Sync your server clock with NTP"}),"\n",(0,r.jsx)(n.li,{children:"Check for network delays"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Always verify signatures in production"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use environment variables for secrets"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Implement timestamp tolerance checks"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use constant-time comparison functions"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Log verification failures for monitoring"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Store the Relae webhook secret separately from vendor secrets"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Implement idempotency using X-Relae-Event-ID"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Return 200 OK only after successful verification"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/guides/managing-webhooks",children:"Managing Webhooks \u2192"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/guides/dead-letter-queue",children:"Dead Letter Queue \u2192"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/endpoints",children:"API Documentation \u2192"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"need-help",children:"Need Help?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\ud83d\udce7 Email: ",(0,r.jsx)(n.a,{href:"mailto:support@relaehook.com",children:"support@relaehook.com"})]}),"\n",(0,r.jsx)(n.li,{children:"\ud83d\udcac Check signature verification in your language"}),"\n",(0,r.jsxs)(n.li,{children:["\ud83d\udc1b Report issues on ",(0,r.jsx)(n.a,{href:"https://github.com/WillBallentine/relae-docs/issues",children:"GitHub"})]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);